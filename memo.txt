1.설정 pip install
pip install -r requirements.txt
2. update
python.exe -m pip install --upgrade pip
3. run
python manage.py runserver

폴더 구조
   * `bani_project`: 웹사이트의 기본 설정파일.
   * `core`: 웹사이트의 기본 구조와 메인 페이지를 담당하는 핵심 앱입니다.
   * `board`: 사용자들이 글을 게시하고 읽을 수 있는 게시판 기능을 담당합니다.
   * `users`: 회원가입, 로그인, 로그아웃 등 사용자 계정 관리를 담당합니다.
   * `weather`: 날씨 정보를 표시하는 기능을 담당합니다.
   * `meal_plans`: 오늘의 식단 정보를 제공하는 기능을 담당합니다.
   * `map`: 지도 관련 기능을 담당할 앱입니다. (현재는 빈 페이지)
   * `market`: 중고 거래 기능을 담당할 앱입니다. (이전 trade 앱)
   * `dating`: 데이팅/매칭 기능을 담당할 앱입니다. (현재는 빈 페이지)

-깃 연결
 git remote add origin https://github.com/Mingyu7/bani.git
 git clone https://github.com/Mingyu7/bani.git

-브랜치 생성
 git checkout -b 'name'
-main 브랜치와 동기화
 git pull origin main
-Push
 git add .
 git commit -m 'message'
 git push origin name

# db모델링 
from django.db import models
from django.contrib.auth.models import AbstractUser


# ✅ 사용자 모델 (기본 User 확장)
class User(AbstractUser):
    nickname = models.CharField(max_length=30, unique=True)              # 닉네임 (고유)
    region = models.CharField(max_length=50, blank=True)                 # 지역 (선택사항)
    rating = models.FloatField(default=0)                                # 평점 (0~5)
    profile_image = models.ImageField(upload_to='profiles/',             # 프로필 이미지 경로
                                      blank=True, null=True)

    def __str__(self):
        return self.nickname


# ✅ 카테고리 모델 (상품, 게시글 공용)
class Category(models.Model):
    CATEGORY_TYPE = [
        ('product', 'Product'),   # 상품용 카테고리
        ('post', 'Post'),         # 게시글용 카테고리
    ]
    name = models.CharField(max_length=50)                               # 카테고리 이름
    type = models.CharField(max_length=20, choices=CATEGORY_TYPE)        # 구분 (상품/게시글)

    def __str__(self):
        return f"{self.name} ({self.type})"


# ✅ 중고거래 매물 모델
class Product(models.Model):
    STATUS_CHOICES = [
        ('sale', '판매중'),
        ('reserved', '예약중'),
        ('sold', '판매완료'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE,             # 판매자 (User 연결)
                             related_name='products')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL,    # 카테고리 (선택)
                                 null=True, blank=True)
    title = models.CharField(max_length=100)                             # 매물 제목
    description = models.TextField()                                     # 매물 설명
    price = models.PositiveIntegerField()                                # 가격 (양수)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES,     # 거래 상태
                              default='sale')
    created_at = models.DateTimeField(auto_now_add=True)                 # 등록일시

    def __str__(self):
        return self.title


# ✅ 게시판 글 모델
class Post(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE,             # 작성자 (User 연결)
                             related_name='posts')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL,    # 게시판 카테고리
                                 null=True, blank=True)
    title = models.CharField(max_length=100)                             # 게시글 제목
    content = models.TextField()                                         # 게시글 내용
    created_at = models.DateTimeField(auto_now_add=True)                 # 작성일시

    def __str__(self):
        return self.title


# ✅ 댓글 모델 (게시글용)
class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE,             # 어떤 게시글의 댓글인지
                             related_name='comments')
    user = models.ForeignKey(User, on_delete=models.CASCADE)             # 댓글 작성자
    parent = models.ForeignKey('self', on_delete=models.CASCADE,         # 부모 댓글 (대댓글용)
                               null=True, blank=True,
                               related_name='replies')
    content = models.TextField()                                         # 댓글 내용
    created_at = models.DateTimeField(auto_now_add=True)                 # 작성일시

    def __str__(self):
        return f"{self.user.nickname}: {self.content[:20]}"


# ✅ 즐겨찾기 (찜 기능)
class Favorite(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE,             # 찜한 유저
                             related_name='favorites')
    product = models.ForeignKey(Product, on_delete=models.CASCADE,       # 찜한 상품
                                related_name='favorites')
    created_at = models.DateTimeField(auto_now_add=True)                 # 찜한 날짜

    class Meta:
        unique_together = ('user', 'product')                            # 한 유저가 같은 상품을 중복 찜 불가

    def __str__(self):
        return f"{self.user.nickname} ♥ {self.product.title}"


# ✅ 채팅방 모델
class ChatRoom(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE,       # 어떤 상품의 채팅방인지
                                related_name='chatrooms')
    seller = models.ForeignKey(User, on_delete=models.CASCADE,           # 판매자
                               related_name='chatrooms_as_seller')
    buyer = models.ForeignKey(User, on_delete=models.CASCADE,            # 구매자
                              related_name='chatrooms_as_buyer')
    created_at = models.DateTimeField(auto_now_add=True)                 # 채팅방 생성 시간

    class Meta:
        unique_together = ('product', 'seller', 'buyer')                 # 동일 상품+유저 중복 방지

    def __str__(self):
        return f"Chat: {self.product.title} ({self.buyer.nickname} ↔ {self.seller.nickname})"


# ✅ 채팅 메시지 모델
class Message(models.Model):
    chatroom = models.ForeignKey(ChatRoom, on_delete=models.CASCADE,     # 어떤 채팅방의 메시지인지
                                 related_name='messages')
    sender = models.ForeignKey(User, on_delete=models.CASCADE)           # 보낸 사람
    content = models.TextField()                                         # 메시지 내용
    sent_at = models.DateTimeField(auto_now_add=True)                    # 전송 시각
    is_read = models.BooleanField(default=False)                         # 읽음 여부

    def __str__(self):
        return f"{self.sender.nickname}: {self.content[:20]}"

